#!/usr/bin/env bash

# Get script and project directories
TRANSLATOR_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )/.." && pwd )"

# Check for help argument
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
	echo "Usage: $0 [project_directory] [file_path]"
	echo ""
	echo "Automatically translates markdown files from the source language to all target languages."
	echo "Uses a cache system to avoid retranslating unchanged blocks."
	echo ""
	echo "Arguments:"
	echo "  project_directory  Optional. If not provided, the parent directory of the translator folder will be used."
	echo "  file_path          Optional. If provided, only this single file will be translated."
	echo "                     Can be an absolute path or relative to the project directory."
	echo ""
	echo "Configuration is loaded from your project's translator.config.yaml and translator.models.yaml files."
	exit 0
fi

# Parse arguments
SINGLE_FILE_PATH=""
ABSOLUTE_FILE_PATH=""
if [ -z "$1" ]; then
	PROJECT_DIR="$( cd "$TRANSLATOR_DIR/.." && pwd )"
elif [ -f "$1" ] && [ -z "$2" ]; then
	# First argument is a file (and no second arg)
	ABSOLUTE_FILE_PATH="$( cd "$(dirname "$1")" && pwd )/$(basename "$1")"
	PROJECT_DIR="$( cd "$(dirname "$1")/.." && pwd )"
elif [ -d "$1" ] && [ -z "$2" ]; then
	# First argument is a directory (and no second arg)
	PROJECT_DIR="$( cd "$1" && pwd )"
else
	# Two arguments: project directory and file path
	PROJECT_DIR="$( cd "$1" && pwd )"
	if [[ "$2" = /* ]]; then
		# Absolute path
		ABSOLUTE_FILE_PATH="$2"
	else
		# Relative path - make it relative to project directory
		SINGLE_FILE_PATH="$2"
	fi
fi

# Try to get project name from git remote, fallback to directory name
if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
	REMOTE_URL=$(git config --get remote.origin.url)
	if [ -n "$REMOTE_URL" ]; then
		PROJECT_NAME=$(basename -s .git "$REMOTE_URL")
	else
		PROJECT_NAME=$(basename "$PROJECT_DIR")
	fi
else
	PROJECT_NAME=$(basename "$PROJECT_DIR")
fi

# Source library functions
source "$TRANSLATOR_DIR/bin/lib.sh"

# Load project configuration
load_config "$TRANSLATOR_DIR" "$PROJECT_DIR"

# Load translation models
load_models "$TRANSLATOR_DIR" "$PROJECT_DIR"

# Initialize cache
init_cache

# Verify configuration is loaded correctly
echo "Using project directory: $PROJECT_DIR"
echo "Source directory: $SOURCE_DIR"
echo "Target directory: $TARGET_DIR"
echo "Translation chunk size: $TRANSLATION_CHUNK_SIZE"
echo "Translation parallel chunks: ${TRANSLATION_PARALLEL_CHUNKS:-4}"
echo "Translation parallel files: ${TRANSLATION_PARALLEL_FILES:-1}"
echo "Cache directory: $CACHE_DIR"

# Find other languages - first try config, then fall back to directories
languages=()
if [ ${#CONFIG_LANGUAGES[@]} -gt 0 ]; then
	# Use languages from config
	languages=("${CONFIG_LANGUAGES[@]}")
	echo "Languages to translate (from config): ${languages[*]}"
else
	# Fall back to detecting from directories
	for language in "$TARGET_DIR"/*/; do
		if [ -d "$language" ] && [ "$language" != "$SOURCE_DIR" ]; then
			dir_name=$(basename "$language")
			if [ "$dir_name" != "english" ]; then
				languages+=("$dir_name")
			fi
		fi
	done
	echo "Languages to translate (from directories): ${languages[*]}"
fi

if [ ${#languages[@]} -eq 0 ]; then
	echo "Error: No languages specified for translation."
	echo "Please add a 'languages:' section to translator.config.yaml or create language directories in $TARGET_DIR"
	exit 1
fi

# Function to extract code blocks and replace them with placeholders
extract_code_blocks() {
	local content="$1"
	local temp_content=$(mktemp)
	local blocks_dir=$(mktemp -d)
	local block_index=0
	local in_code_block=false
	local current_block=""

	while IFS= read -r line || [ -n "$line" ]; do
		if [[ "$line" =~ ^(\s*)(\`\`\`)(.*)$ ]]; then
			if [ "$in_code_block" = false ]; then
				in_code_block=true
				current_block="$line"
			else
				current_block+=$'\n'"$line"
				echo "$current_block" > "$blocks_dir/block_$block_index"
				echo "CODE_BLOCK_$block_index" >> "$temp_content"
				((block_index++))
				in_code_block=false
				current_block=""
			fi
		elif [ "$in_code_block" = true ]; then
			current_block+=$'\n'"$line"
		else
			echo "$line" >> "$temp_content"
		fi
	done <<< "$content"

	if [ "$in_code_block" = true ]; then
		echo "$current_block" > "$blocks_dir/block_$block_index"
		echo "CODE_BLOCK_$block_index" >> "$temp_content"
		((block_index++))
	fi

	echo "$temp_content $blocks_dir $block_index"
}

# Function to restore code blocks
restore_code_blocks() {
	local content_file="$1"
	local output_file="$2"
	local blocks_dir="$3"
	local block_count="$4"

	> "$output_file"

	while IFS= read -r line || [ -n "$line" ]; do
		if [[ "$line" =~ ^CODE_BLOCK_([0-9]+)$ ]]; then
			local code_block_index="${BASH_REMATCH[1]}"
			if [ -f "$blocks_dir/block_$code_block_index" ]; then
				cat "$blocks_dir/block_$code_block_index" >> "$output_file"
			else
				echo "ERROR: Missing code block $code_block_index" >> "$output_file"
			fi
		else
			echo "$line" >> "$output_file"
		fi
	done < "$content_file"

	if [[ "$(tail -c1 "$content_file")" != "" ]]; then
		truncate -s -1 "$output_file"
	fi

	rm -rf "$blocks_dir"
}

# Translate a single chunk, checking cache first
translate_chunk_with_cache() {
	local chunk="$1"
	local language="$2"
	local output_file="$3"
	local chunk_index="$4"
	local relative_path="$5"

	# Calculate hash for this chunk
	local block_hash=$(calculate_block_hash "$chunk")

	# Check if it's a code block or comment (should not be translated)
	if is_code_block_or_comment "$chunk"; then
		# Save to cache with original as translation
		save_to_cache "$block_hash" "$chunk" "$language" "$chunk" "true" "$relative_path"
		printf "%s" "$chunk" > "$output_file"
		return 0
	fi

	# Check cache first
	local cached_translation
	if cached_translation=$(get_cached_translation "$block_hash" "$language" "$relative_path"); then
		# Use cached translation
		echo "  chunk $chunk_index: using cache" >&2
		printf "%s" "$cached_translation" > "$output_file"
		return 0
	fi
	
	# Not in cache, need to translate
	if [ -n "$chunk_index" ]; then
		echo "  chunk $chunk_index: translating..." >&2
	else
		echo "  translating chunk..." >&2
	fi
	local translation_temp=$(mktemp)
	local source_temp=$(mktemp)
	# Write chunk to temp file, ensuring it ends with newline if chunk doesn't end with one
	# This ensures consistent line counting
	if [[ "$chunk" =~ $'\n'$ ]]; then
		printf "%s" "$chunk" > "$source_temp"
	else
		printf "%s\n" "$chunk" > "$source_temp"
	fi
	
	local source_lines=$(grep -c '[^[:space:]]' < "$source_temp" || echo "0")
	max_models=${#ATTEMPTS[@]}
	max_attempts=$((max_models * 2))
	local attempt=1
	
	while [ $attempt -le $max_attempts ]; do
		local model_index=$(( (attempt - 1) / 2 + 1 ))
		local retry_in_model=$(( (attempt - 1) % 2 + 1 ))
		model=${ATTEMPTS[$model_index]}
		
		echo "    Attempt $attempt of $max_attempts (model $model_index/$max_models, retry $retry_in_model/2) with $model..." >&2
		> "$translation_temp"

		local aichat_output
		local aichat_exit_code
		aichat_output=$(printf "%s" "$chunk" | aichat -m "$model" --role "$PROJECT_NAME-translate-to-$language" -S 2>&1)
		aichat_exit_code=$?
		
		if [ $aichat_exit_code -ne 0 ]; then
			echo "    Translation command failed (exit code: $aichat_exit_code)" >&2
			if [ $attempt -eq 1 ]; then
				echo "    Error output: ${aichat_output:0:200}" >&2
			fi
			# Don't return immediately - try next model/attempt
			if [ $retry_in_model -eq 2 ]; then
				# Last retry for this model, continue to next model
				((attempt++))
				continue
			fi
			((attempt++))
			continue
		fi
		
		# Write translation to temp file, ensuring it ends with newline if output doesn't end with one
		# This ensures consistent line counting for structure matching
		if [[ "$aichat_output" =~ $'\n'$ ]]; then
			printf "%s" "$aichat_output" > "$translation_temp"
		else
			printf "%s\n" "$aichat_output" > "$translation_temp"
		fi
		
		local has_invalid_keys=
		if [ "$CHECK_YAML_KEYS" = true ]; then
			has_invalid_keys=$(yq '.. | select(.) | path | join(".")' < "$translation_temp" 2>/dev/null | grep -E '[^a-zA-Z0-9_.-]')
		fi

		if check_line_structure_match "$source_temp" "$translation_temp" && [ -z "$has_invalid_keys" ]; then
			# Success - save to cache and return
			save_to_cache "$block_hash" "$chunk" "$language" "$aichat_output" "false" "$relative_path"
			printf "%s" "$aichat_output" > "$output_file"
			rm -f "$translation_temp" "$source_temp"
			return 0
		else
			if [ -n "$has_invalid_keys" ]; then
				echo "    Warning: Invalid keys in chunk (attempt $attempt/$max_attempts)" >&2
			fi
			if ! check_line_structure_match "$source_temp" "$translation_temp"; then
				echo "    Warning: Line structure mismatch (attempt $attempt/$max_attempts)" >&2
			fi
			
			if [ $retry_in_model -eq 2 ]; then
				echo "    Model $model failed after 2 attempts, moving to next model" >&2
			fi
		fi

		((attempt++))
	done

	echo "    Error: Failed to get valid translation after $max_attempts attempts" >&2
	rm -f "$translation_temp" "$source_temp"
	return 1
}

# Check if file needs translation by comparing line counts and cache
needs_translation() {
	local source_file="$1"
	local target_file="$2"
	local language="$3"
	local relative_path="$4"
	
	# If target doesn't exist, needs translation
	if [ ! -f "$target_file" ]; then
		return 0
	fi
	
	# Compare line counts
	local source_lines=$(wc -l < "$source_file" 2>/dev/null || echo "0")
	local target_lines=$(wc -l < "$target_file" 2>/dev/null || echo "0")
	
	if [ "$source_lines" != "$target_lines" ]; then
		return 0
	fi
	
	# Line counts match, but check if structure (empty line positions) matches
	# If structure changed, we need to retranslate even if chunks are cached
	# because cached translations were created for the old structure
	local source_empty_lines=""
	local target_empty_lines=""
	local line_num=0
	
	# Get empty line positions from source
	while IFS= read -r line || [ -n "$line" ]; do
		((line_num++))
		if [[ -z "$line" ]] || [[ "$line" =~ ^[[:space:]]*$ ]]; then
			if [ -z "$source_empty_lines" ]; then
				source_empty_lines="$line_num"
			else
				source_empty_lines="$source_empty_lines $line_num"
			fi
		fi
	done < "$source_file"
	
	# Get empty line positions from target
	line_num=0
	while IFS= read -r line || [ -n "$line" ]; do
		((line_num++))
		if [[ -z "$line" ]] || [[ "$line" =~ ^[[:space:]]*$ ]]; then
			if [ -z "$target_empty_lines" ]; then
				target_empty_lines="$line_num"
			else
				target_empty_lines="$target_empty_lines $line_num"
			fi
		fi
	done < "$target_file"
	
	# If empty line positions don't match, structure changed - need retranslation
	if [ "$source_empty_lines" != "$target_empty_lines" ]; then
		return 0
	fi
	
	# Structure matches, check if there are new chunks in source not in cache
	local source_content=$(<"$source_file")
	
	# Extract code blocks first
	local extraction_result=$(extract_code_blocks "$source_content")
	read -r content_file blocks_dir block_count <<< "$extraction_result"
	local content_with_placeholders=$(<"$content_file")
	
	# Split into chunks
	IFS=$'\n\n' read -r -d '' -a raw_chunks <<< "$content_with_placeholders"
	
	declare -a chunks=()
	local current_chunk=""
	local current_size=0
	
	for raw_chunk in "${raw_chunks[@]}"; do
		local chunk_size=${#raw_chunk}
		if [ $((current_size + chunk_size)) -gt "$TRANSLATION_CHUNK_SIZE" ]; then
			if [ -n "$current_chunk" ]; then
				chunks+=("$current_chunk")
			fi
			current_chunk="$raw_chunk"
			current_size=$chunk_size
		else
			if [ -n "$current_chunk" ]; then
				current_chunk+=$'\n\n'"$raw_chunk"
				current_size=$((current_size + chunk_size + 2))
			else
				current_chunk="$raw_chunk"
				current_size=$chunk_size
			fi
		fi
	done
	
	if [ -n "$current_chunk" ]; then
		chunks+=("$current_chunk")
	fi
	
	# Check if all chunks are in cache
	for chunk in "${chunks[@]}"; do
		local block_hash=$(calculate_block_hash "$chunk")
		if ! get_cached_translation "$block_hash" "$language" "$relative_path" >/dev/null 2>&1; then
			# Found a chunk not in cache
			rm -f "$content_file"
			rm -rf "$blocks_dir"
			return 0
		fi
	done
	
	# All chunks are in cache and structure matches
	rm -f "$content_file"
	rm -rf "$blocks_dir"
	return 1
}

# Translate a file using cache
translate_file() {
	local relative_path="$1"
	local source_file="$SOURCE_DIR/$relative_path"
	local translation_failed=0
	local translation_occurred=0

	for language in "${languages[@]}"; do
		echo " -> $language"
		local target_path="$TARGET_DIR/$language/$relative_path"
		
		# Check if translation is needed
		local needs_trans=0
		if ! needs_translation "$source_file" "$target_path" "$language" "$relative_path"; then
			needs_trans=0
		else
			needs_trans=1
		fi
		
		# If file is up to date, skip translation
		if [ $needs_trans -eq 0 ]; then
			echo "  up to date"
			continue
		fi
		
		local file_existed_before=false
		if [ -f "$target_path" ]; then
			file_existed_before=true
		fi

		local dir=$(dirname "$target_path")
		if [ ! -d "$dir" ]; then
			mkdir -p "$dir"
		fi

		# Read source content
		local source_content=$(<"$source_file")
		
		# Extract code blocks
		local extraction_result=$(extract_code_blocks "$source_content")
		read -r content_file blocks_dir block_count <<< "$extraction_result"
		local content_with_placeholders=$(<"$content_file")
		
		# Split into chunks
		IFS=$'\n\n' read -r -d '' -a raw_chunks <<< "$content_with_placeholders"
		
		declare -a chunks=()
		local current_chunk=""
		local current_size=0
		
		for raw_chunk in "${raw_chunks[@]}"; do
			local chunk_size=${#raw_chunk}
			if [ $((current_size + chunk_size)) -gt "$TRANSLATION_CHUNK_SIZE" ]; then
				if [ -n "$current_chunk" ]; then
					chunks+=("$current_chunk")
				fi
				current_chunk="$raw_chunk"
				current_size=$chunk_size
			else
				if [ -n "$current_chunk" ]; then
					current_chunk+=$'\n\n'"$raw_chunk"
					current_size=$((current_size + chunk_size + 2))
				else
					current_chunk="$raw_chunk"
					current_size=$chunk_size
				fi
			fi
		done
		
		if [ -n "$current_chunk" ]; then
			chunks+=("$current_chunk")
		fi
		
		if [ ${#chunks[@]} -eq 0 ]; then
			echo "  no content to translate"
			rm -f "$content_file"
			rm -rf "$blocks_dir"
			continue
		fi
		
		translation_occurred=1
		local temp_file=$(mktemp)
		
		# Translate chunks (checking cache first)
		local num_chunks=${#chunks[@]}
		# Ensure parallel_limit is a valid integer (strip any whitespace/newlines and take only first number)
		local parallel_limit=$(echo "${TRANSLATION_PARALLEL_CHUNKS:-4}" | tr -d '[:space:]' | head -c 10)
		# Validate it's a number, default to 4 if not
		if ! [[ "$parallel_limit" =~ ^[0-9]+$ ]]; then
			parallel_limit=4
		fi
		
		if [ "$num_chunks" -gt 1 ] && [ "$parallel_limit" -gt 1 ]; then
			# Parallel processing
			echo "  translating $num_chunks chunks (max $parallel_limit concurrent)"
			declare -a chunk_temp_files=()
			declare -a chunk_pids=()
			local active_jobs=0
			local chunk_index=0
			
			for chunk in "${chunks[@]}"; do
				((chunk_index++))
				
				while [ $active_jobs -ge "$parallel_limit" ]; do
					local found=0
					for idx in "${!chunk_pids[@]}"; do
						if [ -n "${chunk_pids[$idx]}" ] && ! kill -0 "${chunk_pids[$idx]}" 2>/dev/null; then
							wait "${chunk_pids[$idx]}"
							if [ $? -ne 0 ]; then
								translation_failed=1
							fi
							chunk_pids[$idx]=""
							((active_jobs--))
							found=1
							break
						fi
					done
					if [ $found -eq 0 ]; then
						sleep 0.1
					fi
				done
				
				local chunk_temp=$(mktemp)
				chunk_temp_files+=("$chunk_temp")
				
				(
					translate_chunk_with_cache "$chunk" "$language" "$chunk_temp" "$chunk_index" "$relative_path"
					echo $? > "${chunk_temp}.exit"
				) &
				local pid=$!
				chunk_pids+=("$pid")
				((active_jobs++))
			done
			
			for pid in "${chunk_pids[@]}"; do
				if [ -n "$pid" ]; then
					wait "$pid" 2>/dev/null
					if [ $? -ne 0 ]; then
						translation_failed=1
					fi
				fi
			done
			
			if [ $translation_failed -eq 0 ]; then
				> "$temp_file"
				for i in "${!chunks[@]}"; do
					if [ -f "${chunk_temp_files[$i]}.exit" ]; then
						local exit_code=$(cat "${chunk_temp_files[$i]}.exit")
						if [ $exit_code -ne 0 ]; then
							translation_failed=1
							echo "  Error: chunk $((i+1)) failed"
							break
						fi
					fi
					if [ -f "${chunk_temp_files[$i]}" ] && [ -s "${chunk_temp_files[$i]}" ]; then
						cat "${chunk_temp_files[$i]}" >> "$temp_file"
						if [ $i -lt $((${#chunks[@]} - 1)) ]; then
							echo "" >> "$temp_file"
						fi
					fi
				done
			fi
			
			rm -f "${chunk_temp_files[@]}" "${chunk_temp_files[@]/%/.exit}"
		else
			# Sequential processing
			local chunk_index=0
			> "$temp_file"
			for chunk in "${chunks[@]}"; do
				((chunk_index++))
				local chunk_temp=$(mktemp)
				if ! translate_chunk_with_cache "$chunk" "$language" "$chunk_temp" "$chunk_index" "$relative_path"; then
					echo "  Error: translation failed for chunk $chunk_index"
					rm -f "$chunk_temp"
					translation_failed=1
					break
				fi
				if [ -s "$chunk_temp" ]; then
					cat "$chunk_temp" >> "$temp_file"
					if [ $chunk_index -lt ${#chunks[@]} ]; then
						echo "" >> "$temp_file"
					fi
				fi
				rm -f "$chunk_temp"
			done
		fi
		
		if [ $translation_failed -eq 0 ]; then
			# Restore code blocks
			local restored_file=$(mktemp)
			restore_code_blocks "$temp_file" "$restored_file" "$blocks_dir" "$block_count"
			
			# Synchronize with source structure
			local synced_file=$(mktemp)
			if sync_files "$source_file" "$restored_file" > "$synced_file"; then
				# Validate the translated file
				if validate_translation "$source_file" "$synced_file"; then
					mv "$synced_file" "$target_path"
					echo "  completed: $target_path"
				else
					echo "  error: validation failed for $target_path"
					rm -f "$synced_file"
					# Clear all cache entries for this file since validation failed
					clear_file_cache "$relative_path"
					translation_failed=1
					if [ "$file_existed_before" = false ]; then
						rm -f "$target_path"
					fi
				fi
			else
				echo "  error: failed to sync files"
				rm -f "$synced_file"
				# Clear all cache entries for this file since sync failed
				clear_file_cache "$relative_path"
				translation_failed=1
				if [ "$file_existed_before" = false ]; then
					rm -f "$target_path"
				fi
			fi
			rm -f "$restored_file"
		fi
		
		if [ $translation_failed -eq 1 ] && [ "$file_existed_before" = false ]; then
			rm -f "$target_path"
		fi
		
		rm -f "$temp_file" "$content_file"
		rm -rf "$blocks_dir"
	done
	
	if [ $translation_failed -eq 1 ]; then
		return 1
	elif [ $translation_occurred -eq 0 ]; then
		return 2
	else
		return 0
	fi
}

# Copy non-MD files
copy_non_md_files() {
	local dir="$1"
	find "$dir" -type f ! -name "*.md" -print0 | while IFS= read -r -d '' file; do
		local relative_path=${file#"$SOURCE_DIR"/}
		for language in "${languages[@]}"; do
			local target_path="$TARGET_DIR/$language/$relative_path"
			if [ ! -f "$target_path" ]; then
				echo "Copying non-MD file: $relative_path to $language"
				local target_dir=$(dirname "$target_path")
				mkdir -p "$target_dir"
				cp "$file" "$target_path"
			fi
		done
	done
}

# Process markdown files
process_markdown_files() {
	local dir="$1"
	local process_failed=0
	
	mapfile -t markdown_files < <(find "$dir" -type f -name "*.md")
	local num_files=${#markdown_files[@]}
	# Ensure parallel_limit is a valid integer (strip any whitespace/newlines and take only first number)
	local parallel_limit=$(echo "${TRANSLATION_PARALLEL_FILES:-1}" | tr -d '[:space:]' | head -c 10)
	# Validate it's a number, default to 1 if not
	if ! [[ "$parallel_limit" =~ ^[0-9]+$ ]]; then
		parallel_limit=1
	fi
	
	if [ "$parallel_limit" -gt 1 ] && [ $num_files -gt 1 ]; then
		# Parallel file processing
		local active_jobs=0
		declare -a file_pids=()
		
		for file in "${markdown_files[@]}"; do
			local relative_path=${file#"$SOURCE_DIR"/}
			
			# Wait for available slot
			while [ $active_jobs -ge "$parallel_limit" ]; do
				local found=0
				for idx in "${!file_pids[@]}"; do
					if [ -n "${file_pids[$idx]}" ] && ! kill -0 "${file_pids[$idx]}" 2>/dev/null; then
						wait "${file_pids[$idx]}"
						local file_result=$?
						if [ $file_result -eq 1 ]; then
							process_failed=1
						fi
						file_pids[$idx]=""
						((active_jobs--))
						found=1
						break
					fi
				done
				if [ $found -eq 0 ]; then
					sleep 0.1
				fi
			done
			
			# Start translation in background
			(
				echo "Processing: $relative_path"
				translate_file "$relative_path"
				local translate_result=$?
				if [ $translate_result -eq 1 ]; then
					echo "Warning: Translation failed for $relative_path" >&2
				elif [ $translate_result -eq 2 ]; then
					echo "No translation needed for $relative_path" >&2
				fi
				exit $translate_result
			) &
			local pid=$!
			file_pids+=("$pid")
			((active_jobs++))
		done
		
		# Wait for all remaining jobs
		for pid in "${file_pids[@]}"; do
			if [ -n "$pid" ]; then
				wait "$pid" 2>/dev/null
				if [ $? -eq 1 ]; then
					process_failed=1
				fi
			fi
		done
	else
		# Sequential file processing
		for file in "${markdown_files[@]}"; do
			local relative_path=${file#"$SOURCE_DIR"/}
			echo "Processing: $relative_path"
			
			translate_file "$relative_path"
			local translate_result=$?
			
			if [ $translate_result -eq 1 ]; then
				echo "Warning: Translation failed for $relative_path"
				process_failed=1
			elif [ $translate_result -eq 2 ]; then
				echo "No translation needed for $relative_path"
			fi
		done
	fi
	
	return $process_failed
}

# Clean up deleted files in target languages
cleanup_deleted_files() {
	for language in "${languages[@]}"; do
		local lang_dir="$TARGET_DIR/$language"
		if [ ! -d "$lang_dir" ]; then
			continue
		fi
		
		find "$lang_dir" -type f -name "*.md" | while read -r target_file; do
			local relative_path=${target_file#"$lang_dir"/}
			local source_file="$SOURCE_DIR/$relative_path"
			
			if [ ! -f "$source_file" ]; then
				echo "Removing deleted file: $relative_path from $language"
				rm -f "$target_file"
			fi
		done
	done
}

# Check if source directory exists
if [ ! -d "$SOURCE_DIR" ]; then
	echo "Error: Source directory does not exist"
	exit 1
fi

# Check prerequisites
check_prerequisites "${languages[@]}"

# Check and install translation roles
check_translation_roles || {
	echo "Error setting up translation roles"
	exit 1
}

# Clean up deleted files first
cleanup_deleted_files

# Process markdown files
if [ -n "$SINGLE_FILE_PATH" ] || [ -n "$ABSOLUTE_FILE_PATH" ]; then
	# Translate a single file
	file_rel_path=""
	
	if [ -n "$ABSOLUTE_FILE_PATH" ]; then
		# Convert absolute path to relative path from SOURCE_DIR
		file_rel_path=${ABSOLUTE_FILE_PATH#"$SOURCE_DIR"/}
		if [ "$file_rel_path" = "$ABSOLUTE_FILE_PATH" ]; then
			# File is not under SOURCE_DIR, try to find it
			echo "Error: File $ABSOLUTE_FILE_PATH is not under source directory $SOURCE_DIR"
			exit 1
		fi
	elif [ -n "$SINGLE_FILE_PATH" ]; then
		# Relative path - check if it's already relative to SOURCE_DIR or PROJECT_DIR
		# First, try as-is relative to SOURCE_DIR
		if [ -f "$SOURCE_DIR/$SINGLE_FILE_PATH" ]; then
			# Already relative to SOURCE_DIR
			file_rel_path="$SINGLE_FILE_PATH"
		# Try relative to PROJECT_DIR
		elif [ -f "$PROJECT_DIR/$SINGLE_FILE_PATH" ]; then
			# Relative to PROJECT_DIR, convert to relative to SOURCE_DIR
			abs_path="$( cd "$PROJECT_DIR" && cd "$(dirname "$SINGLE_FILE_PATH")" && pwd )/$(basename "$SINGLE_FILE_PATH")"
			file_rel_path=${abs_path#"$SOURCE_DIR"/}
			if [ "$file_rel_path" = "$abs_path" ]; then
				echo "Error: File $SINGLE_FILE_PATH is not under source directory $SOURCE_DIR"
				exit 1
			fi
		# Try stripping source directory prefix if present
		else
			# Extract source directory relative path from PROJECT_DIR
			source_dir_relative="${SOURCE_DIR#$PROJECT_DIR/}"
			if [[ "$SINGLE_FILE_PATH" == "$source_dir_relative"/* ]]; then
				# Path starts with source directory, strip it
				file_rel_path=${SINGLE_FILE_PATH#"$source_dir_relative"/}
				if [ ! -f "$SOURCE_DIR/$file_rel_path" ]; then
					echo "Error: File not found: $SINGLE_FILE_PATH"
					exit 1
				fi
			else
				echo "Error: File not found: $SINGLE_FILE_PATH (checked $SOURCE_DIR/$SINGLE_FILE_PATH and $PROJECT_DIR/$SINGLE_FILE_PATH)"
				exit 1
			fi
		fi
	fi
	
	full_file_path="$SOURCE_DIR/$file_rel_path"
	if [ ! -f "$full_file_path" ]; then
		echo "Error: File not found: $full_file_path"
		exit 1
	fi
	
	if [[ "$file_rel_path" != *.md ]]; then
		echo "Error: File must be a markdown file (.md): $file_rel_path"
		exit 1
	fi
	
	echo "Translating single file: $file_rel_path"
	translate_file "$file_rel_path"
	translate_result=$?
	
	if [ $translate_result -eq 1 ]; then
		echo "Warning: Translation failed for $file_rel_path"
		exit 1
	elif [ $translate_result -eq 2 ]; then
		echo "No translation needed for $file_rel_path"
	fi
else
	# Process all markdown files
	process_markdown_files "$SOURCE_DIR"
	
	# Copy non-MD files
	copy_non_md_files "$SOURCE_DIR"
fi

echo "Processing complete."
