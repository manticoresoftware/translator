#!/usr/bin/env bash

# Get script and project directories
TRANSLATOR_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )/.." && pwd )"

# Check for help argument
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
	echo "Usage: $0 [project_directory]"
	echo ""
	echo "Automatically translates markdown files from the source language to all target languages."
	echo ""
	echo "If project_directory is not provided, the parent directory of the translator folder will be used."
	echo "Configuration is loaded from your project's translator.config.yaml and translator.models.yaml files."
	echo "If these files don't exist, default configuration values will be used."
	exit 0
fi

# If no project directory specified, use parent directory
if [ -z "$1" ]; then
	PROJECT_DIR="$( cd "$TRANSLATOR_DIR/.." && pwd )"
else
	PROJECT_DIR="$( cd "$1" && pwd )"
fi

# Try to get project name from git remote, fallback to directory name
if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
	# Try to extract repository name from git remote URL
	REMOTE_URL=$(git config --get remote.origin.url)
	if [ -n "$REMOTE_URL" ]; then
		# Remove .git suffix and extract repo name
		PROJECT_NAME=$(basename -s .git "$REMOTE_URL")
	else
		# Fallback to directory name
		PROJECT_NAME=$(basename "$PROJECT_DIR")
	fi
else
	# Not in a git repository, use directory name
	PROJECT_NAME=$(basename "$PROJECT_DIR")
fi

# Source library functions
source "$TRANSLATOR_DIR/bin/lib.sh"

# Load project configuration
load_config "$TRANSLATOR_DIR" "$PROJECT_DIR"

# Load translation models
load_models "$TRANSLATOR_DIR" "$PROJECT_DIR"

# Verify configuration is loaded correctly
echo "Using project directory: $PROJECT_DIR"
echo "Source directory: $SOURCE_DIR"
echo "Target directory: $TARGET_DIR"
echo "Translation chunk size: $TRANSLATION_CHUNK_SIZE"
echo "Main branch: $MAIN_BRANCH"
echo "MD5 file: $MD5_FILE_PATH"
echo "Role template: $ROLE_TEMPLATE"

# Find other languages
languages=()
for language in "$TARGET_DIR"/*/; do
	if [ -d "$language" ] && [ "$language" != "$SOURCE_DIR" ]; then
		dir_name=$(basename "$language")
		if [ "$dir_name" != "english" ]; then
			languages+=("$dir_name")
		fi
	fi
done

echo "Languages to translate: ${languages[*]}"

# Create a clear file in case of missing
if [ ! -f "$MD5_FILE_PATH" ]; then
	echo "{}" > "$MD5_FILE_PATH"
fi

has_all_languages() {
	local relative_path="$1"
	local all_exist=true

	for language in "${languages[@]}"; do
		target_path="$TARGET_DIR/$language/$relative_path"
		if [ ! -f "$target_path" ]; then
			all_exist=false
			break
		fi
	done

	echo $all_exist
}

# Function to extract code blocks and replace them with placeholders
extract_code_blocks() {
	local content="$1"
	local temp_content=$(mktemp)
	local blocks_dir=$(mktemp -d)
	local block_index=0
	local in_code_block=false
	local current_block=""

	# Process the content line by line to extract code blocks
	while IFS= read -r line || [ -n "$line" ]; do
		if [[ "$line" =~ ^(\s*)(\`\`\`)(.*)$ ]]; then
			if [ "$in_code_block" = false ]; then
				# Start of a code block
				in_code_block=true
				current_block="$line"
			else
				# End of a code block
				current_block+=$'\n'"$line"
				# Write code block to a file
				echo "$current_block" > "$blocks_dir/block_$block_index"
				# Replace with placeholder in the content
				echo "CODE_BLOCK_$block_index" >> "$temp_content"
				((block_index++))
				in_code_block=false
				current_block=""
			fi
		elif [ "$in_code_block" = true ]; then
			# Inside a code block
			current_block+=$'\n'"$line"
		else
			# Regular content
			echo "$line" >> "$temp_content"
		fi
	done <<< "$content"

	# If we're still in a code block at the end, add it anyway (malformed markdown)
	if [ "$in_code_block" = true ]; then
		echo "$current_block" > "$blocks_dir/block_$block_index"
		echo "CODE_BLOCK_$block_index" >> "$temp_content"
		((block_index++))
	fi

	# Return the content file, blocks directory and count
	echo "$temp_content $blocks_dir $block_index"
}

# Function to restore code blocks
restore_code_blocks() {
	local content_file="$1"
	local output_file="$2"
	local blocks_dir="$3"
	local block_count="$4"

	> "$output_file"

	while IFS= read -r line || [ -n "$line" ]; do
		if [[ "$line" =~ ^CODE_BLOCK_([0-9]+)$ ]]; then
			block_index="${BASH_REMATCH[1]}"
			# Get the block from its file
			if [ -f "$blocks_dir/block_$block_index" ]; then
				cat "$blocks_dir/block_$block_index" >> "$output_file"
			else
				echo "ERROR: Missing code block $block_index" >> "$output_file"
			fi
		else
			echo "$line" >> "$output_file"
		fi
	done < "$content_file"

	# Remove trailing newline if the original didn't have one
	if [[ "$(tail -c1 "$content_file")" != "" ]]; then
		truncate -s -1 "$output_file"
	fi

	# Clean up
	rm -rf "$blocks_dir"
}

# Function to extract translatable content from YAML diff file
# Extracts "add" blocks and stores them separately in blocks_dir
# Returns path to temp file used for tracking (with .count and .blocks_dir metadata files)
extract_yaml_diff_content() {
	local yaml_diff_file="$1"
	local temp_content=$(mktemp)
	local blocks_dir=$(mktemp -d)
	local content_mode=false
	local block_content=""
	local add_block_count=0
	local block_index=0

	# Process the YAML diff file line by line
	while IFS= read -r line || [ -n "$line" ]; do
		# Check for add block start
		if [[ $line =~ ^add([0-9]+):\ \| ]]; then
			# Flush previous block if any
			if [ "$content_mode" == true ] && [ -n "$block_content" ]; then
				echo "$block_content" > "$blocks_dir/block_$block_index"
				echo "YAML_BLOCK_SEP_$block_index" >> "$temp_content"
				((block_index++))
			fi
			content_mode=true
			block_content=""
			((add_block_count++))
			continue
		# Check for del block or next add block (end current block)
		elif [[ $line =~ ^(add[0-9]+:\ \||del[0-9]+:) ]]; then
			# Flush current block if any
			if [ "$content_mode" == true ] && [ -n "$block_content" ]; then
				echo "$block_content" > "$blocks_dir/block_$block_index"
				echo "YAML_BLOCK_SEP_$block_index" >> "$temp_content"
				((block_index++))
			fi
			content_mode=false
			block_content=""
			# Start new add block if it's an add
			if [[ $line =~ ^add([0-9]+):\ \| ]]; then
				content_mode=true
			fi
			continue
		fi

		# Collect content from add blocks (remove leading 2 spaces)
		if [ "$content_mode" == true ]; then
			if [[ $line =~ ^[[:space:]]+ ]]; then
				line="${line:2}"  # Remove leading two spaces
			fi
			if [ -z "$block_content" ]; then
				block_content="$line"
			else
				block_content="${block_content}"$'\n'"$line"
			fi
		fi
	done < "$yaml_diff_file"

	# Flush any remaining content
	if [ "$content_mode" == true ] && [ -n "$block_content" ]; then
		echo "$block_content" > "$blocks_dir/block_$block_index"
		echo "YAML_BLOCK_SEP_$block_index" >> "$temp_content"
		((block_index++))
	fi

	# Store block count in a separate file
	echo "$add_block_count" > "${temp_content}.count"
	# Store blocks directory path
	echo "$blocks_dir" > "${temp_content}.blocks_dir"

	echo "$temp_content"
}

# Function to reconstruct YAML diff file with translated content
# Takes original YAML diff, blocks directory with translated blocks, and outputs new YAML diff
reconstruct_yaml_diff() {
	local original_yaml_diff="$1"
	local translated_blocks_dir="$2"
	local output_yaml_diff="$3"
	
	local translated_index=0
	> "$output_yaml_diff"
	local content_mode=false
	local block_content=""
	local current_line_num=""

	# Process the original YAML diff file line by line
	while IFS= read -r line || [ -n "$line" ]; do
		# Check for add block start
		if [[ $line =~ ^add([0-9]+):\ \| ]]; then
			# Flush previous block with translated content
			if [ "$content_mode" == true ] && [ -n "$block_content" ]; then
				# Get translated content for this block
				if [ -f "$translated_blocks_dir/translated_block_$translated_index" ]; then
					# Write translated content with proper indentation, preserving all lines including trailing empty ones
					while IFS= read -r trans_line || [ -n "$trans_line" ]; do
						echo "  $trans_line" >> "$output_yaml_diff"
					done < "$translated_blocks_dir/translated_block_$translated_index"
				else
					# Fallback: use original content if translation is missing
					while IFS= read -r orig_line || [ -n "$orig_line" ]; do
						echo "  $orig_line" >> "$output_yaml_diff"
					done <<< "$block_content"
				fi
				block_content=""
				((translated_index++))
			fi
			current_line_num="${BASH_REMATCH[1]}"
			echo "$line" >> "$output_yaml_diff"
			content_mode=true
			block_content=""
			continue
		# Check for del block or next add/del block (flush current block)
		elif [[ $line =~ ^(add[0-9]+:\ \||del[0-9]+:) ]]; then
			# Flush current add block with translated content
			if [ "$content_mode" == true ] && [ -n "$block_content" ]; then
				# Get translated content for this block
				if [ -f "$translated_blocks_dir/translated_block_$translated_index" ]; then
					# Write translated content with proper indentation, preserving all lines including trailing empty ones
					while IFS= read -r trans_line || [ -n "$trans_line" ]; do
						echo "  $trans_line" >> "$output_yaml_diff"
					done < "$translated_blocks_dir/translated_block_$translated_index"
				else
					# Fallback: use original content if translation is missing
					while IFS= read -r orig_line || [ -n "$orig_line" ]; do
						echo "  $orig_line" >> "$output_yaml_diff"
					done <<< "$block_content"
				fi
				block_content=""
				((translated_index++))
			fi
			content_mode=false
			# Write the new key line
			echo "$line" >> "$output_yaml_diff"
			# Start new add block if it's an add
			if [[ $line =~ ^add([0-9]+):\ \| ]]; then
				current_line_num="${BASH_REMATCH[1]}"
				content_mode=true
			fi
			continue
		fi

		# Collect content from add blocks
		if [ "$content_mode" == true ]; then
			if [[ $line =~ ^[[:space:]]+ ]]; then
				line="${line:2}"  # Remove leading two spaces
			fi
			if [ -z "$block_content" ]; then
				block_content="$line"
			else
				block_content="${block_content}"$'\n'"$line"
			fi
		else
			# Pass through del blocks and other non-content lines
			echo "$line" >> "$output_yaml_diff"
		fi
	done < "$original_yaml_diff"

	# Flush any remaining add block
	if [ "$content_mode" == true ] && [ -n "$block_content" ]; then
		if [ -f "$translated_blocks_dir/translated_block_$translated_index" ]; then
			# Write translated content with proper indentation, preserving all lines including trailing empty ones
			while IFS= read -r trans_line || [ -n "$trans_line" ]; do
				echo "  $trans_line" >> "$output_yaml_diff"
			done < "$translated_blocks_dir/translated_block_$translated_index"
		else
			while IFS= read -r orig_line || [ -n "$orig_line" ]; do
				echo "  $orig_line" >> "$output_yaml_diff"
			done <<< "$block_content"
		fi
	fi
}

translate_chunk() {
	local chunk="$1"
	local language="$2"
	local temp_file="$3"
	local translation_temp=$(mktemp)

	# Create temporary file for source chunk to enable file-based comparison
	local source_temp=$(mktemp)
	echo "$chunk" > "$source_temp"

	# Count lines in source chunk
	local source_lines=$(grep -c '[^[:space:]]' < "$source_temp")

	max_models=${#ATTEMPTS[@]}
	max_attempts=$((max_models * 2))  # Each model gets 2 attempts
	local attempt=1
	
	while [ $attempt -le $max_attempts ]; do
		# Calculate which model to use: (attempt-1)/2 + 1
		local model_index=$(( (attempt - 1) / 2 + 1 ))
		local retry_in_model=$(( (attempt - 1) % 2 + 1 ))
		model=${ATTEMPTS[$model_index]}
		
		echo "    Attempt $attempt of $max_attempts (model $model_index/$max_models, retry $retry_in_model/2) with $model..."
		> "$translation_temp"

		# Attempt translation
		if ! printf "%s" "$chunk" | aichat -m "$model" --role "$PROJECT_NAME-translate-to-$language" -S > "$translation_temp"; then
			echo "    Translation command failed"
			rm -f "$translation_temp" "$source_temp"
			return 1

		fi

		# Count lines in translated chunk
		local translated_lines=$(grep -c '[^[:space:]]' < "$translation_temp")

		local has_invalid_keys=
		if [ "$CHECK_YAML_KEYS" = true ]; then
			has_invalid_keys=$(yq '.. | select(.) | path | join(".")' < "$translation_temp" 2>/dev/null | grep -E '[^a-zA-Z0-9_.-]')
		fi

		# Use optimized line structure matching
		if check_line_structure_match "$source_temp" "$translation_temp" && [ -z "$has_invalid_keys" ]; then
			# Success - append to main temp file and add empty line
			cat "$translation_temp" >> "$temp_file"
			echo "" >> "$temp_file"
			rm -f "$translation_temp" "$source_temp"
			return 0
		else
			# Invalid yaml keys check
			if [ -n "$has_invalid_keys" ]; then
				echo "    Warning: Invalid keys in chunk (attempt $attempt/$max_attempts)"
				echo "    Invalid keys: $has_invalid_keys"
			fi

			# Line structure check
			if ! check_line_structure_match "$source_temp" "$translation_temp"; then
				echo "    Warning: Line structure mismatch in chunk (attempt $attempt/$max_attempts)"
				echo "    Source total lines: $(wc -l < "$source_temp")"
				echo "    Translated total lines: $(wc -l < "$translation_temp")"
			fi

			# Only move to next model if we've exhausted both retries
			if [ $retry_in_model -eq 2 ]; then
				# Optional: Log problematic translations for review before moving to next model
				echo "    Model $model failed after 2 attempts, moving to next model"
			fi
			
			((attempt++))
		fi
	done

# If we get here, all attempts failed
echo "    Error: Failed to get valid translation after $max_attempts attempts"
rm -f "$translation_temp" "$source_temp"
return 1
}

translate_file() {
	local relative_path="$1"
	local diff_file="$2"
	local translation_failed=0
	local translation_occurred=0
	local source_file="$SOURCE_DIR/$relative_path"

	for language in "${languages[@]}"; do
		echo " -> $language"
		target_path="$TARGET_DIR/$language/$relative_path"
		
		# Track if file existed before translation attempt
		file_existed_before=false
		if [ -f "$target_path" ]; then
			file_existed_before=true
		fi
		
		if [ -f "$target_path" ] && [ -z "$diff_file" ]; then
			echo "  exists"
			continue
		fi

		dir=$(dirname "$target_path")
		if [ ! -d "$dir" ]; then
			echo "  creating directory"
			mkdir -p "$dir"
		fi

		# Create temporary file for building the translation
		temp_file=$(mktemp)

		# Read the entire file content or extract content from diff YAML
		if [ -z "$diff_file" ]; then
			# Full file translation case (not diff YAML)
			content=$(<"$source_file")
			use_diff_yaml=false
			
			# Extract code blocks and get transformed content
			echo "  extracting code blocks"
			extraction_result=$(extract_code_blocks "$content")
			read -r content_file_with_placeholders blocks_dir block_count <<< "$extraction_result"

			# Read the transformed content with placeholders
			content_with_placeholders=$(<"$content_file_with_placeholders")

			# Split content into chunks by double newlines (paragraph separation)
			IFS=$'\n\n' read -r -d '' -a raw_chunks <<< "$content_with_placeholders"

			# Initialize variables for chunk processing
			declare -a chunks=()
			current_chunk=""
			current_size=0

			# Process raw chunks and combine them based on byte size
			for raw_chunk in "${raw_chunks[@]}"; do
				chunk_size=${#raw_chunk}

				if [ $((current_size + chunk_size)) -gt "$TRANSLATION_CHUNK_SIZE" ]; then
					# If current chunk is not empty, add it to chunks array
					if [ -n "$current_chunk" ]; then
						chunks+=("$current_chunk")
					fi
					current_chunk="$raw_chunk"
					current_size=$chunk_size
				else
					# Add to current chunk with proper separation
					if [ -n "$current_chunk" ]; then
						current_chunk+=$'\n\n'"$raw_chunk"
						current_size=$((current_size + chunk_size + 2))
					else
						current_chunk="$raw_chunk"
						current_size=$chunk_size
					fi
				fi
			done

			# Add the last chunk if it exists
			if [ -n "$current_chunk" ]; then
				chunks+=("$current_chunk")
			fi

			# Check if there are any chunks to translate
			if [ ${#chunks[@]} -eq 0 ]; then
				echo "  no content to translate, skipping"
				rm -f "$temp_file"
				rm -f "$content_file_with_placeholders"
				continue
			fi
			
			translation_occurred=1

			# Translate each chunk
			local chunk_index=0
			for chunk in "${chunks[@]}"; do
				((chunk_index++))
				chunk_size=${#chunk}
				echo "  translating chunk $chunk_index/${#chunks[@]} ($chunk_size bytes)"

				if ! translate_chunk "$chunk" "$language" "$temp_file"; then
					echo "  Error: translation failed for chunk $chunk_index"
					rm -f "$temp_file"
					rm -f "$content_file_with_placeholders"
					translation_failed=1
					break
				fi
				echo "  chunk $chunk_index completed successfully"
			done

			if [ $translation_failed -eq 0 ]; then
				# Restore code blocks in the translated content
				echo "  restoring code blocks"
				restored_file=$(mktemp)
				restore_code_blocks "$temp_file" "$restored_file" "$blocks_dir" "$block_count"

				# Synchronize files with exact lines position
				if sync_files "$source_file" "$restored_file" > "$target_path"; then
					echo "  completed: $target_path"
				else
					echo "  error: failed to sync files"
					translation_failed=1
					# Only remove if file was created during this translation attempt
					if [ "$file_existed_before" = false ]; then
						rm -f "$target_path"
					fi
				fi

				rm -f "$restored_file"
			fi

			if [ -f "$content_file_with_placeholders" ]; then
				rm -f "$content_file_with_placeholders"
			fi
		else
			# Extract translatable content from YAML diff file
			echo "  extracting content from YAML diff"
			diff_content_file=$(extract_yaml_diff_content "$diff_file")
			diff_block_count_file="${diff_content_file}.count"
			diff_blocks_dir=$(<"${diff_content_file}.blocks_dir")
			
			# Check if there's any content to translate
			if [ ! -s "$diff_content_file" ] || [ -z "$(grep '[^[:space:]]' "$diff_content_file")" ]; then
				echo "  no translatable content in diff, skipping"
				rm -f "$diff_content_file" "$diff_block_count_file" "${diff_content_file}.blocks_dir"
				rm -rf "$diff_blocks_dir"
				rm -f "$temp_file"
				continue
			fi
			
			translation_occurred=1
			use_diff_yaml=true
			
			# Translate each block separately to ensure correct mapping
			local block_index=0
			local translated_blocks_dir=$(mktemp -d)
			local block_file=""
			
			while [ -f "$diff_blocks_dir/block_$block_index" ]; do
				block_file="$diff_blocks_dir/block_$block_index"
				block_content=$(<"$block_file")
				
				# Check if block has non-whitespace content
				if [ -z "$(grep '[^[:space:]]' <<< "$block_content")" ]; then
					# Empty block, copy as-is
					cp "$block_file" "$translated_blocks_dir/translated_block_$block_index"
					((block_index++))
					continue
				fi
				
				# Extract code blocks from this block
				echo "  translating YAML block $((block_index + 1))"
				extraction_result=$(extract_code_blocks "$block_content")
				read -r block_content_file block_code_blocks_dir block_code_count <<< "$extraction_result"
				
				block_content_with_placeholders=$(<"$block_content_file")
				
				# Translate this block
				local block_translation_temp=$(mktemp)
				if ! translate_chunk "$block_content_with_placeholders" "$language" "$block_translation_temp"; then
					echo "  Error: translation failed for YAML block $((block_index + 1))"
					rm -f "$block_translation_temp" "$block_content_file"
					rm -rf "$block_code_blocks_dir"
					rm -rf "$translated_blocks_dir" "$diff_blocks_dir"
					rm -f "$diff_content_file" "$diff_block_count_file" "${diff_content_file}.blocks_dir"
					translation_failed=1
					break
				fi
				
				# Restore code blocks in translated block
				local translated_block_file=$(mktemp)
				restore_code_blocks "$block_translation_temp" "$translated_block_file" "$block_code_blocks_dir" "$block_code_count"
				cp "$translated_block_file" "$translated_blocks_dir/translated_block_$block_index"
				
				rm -f "$block_translation_temp" "$block_content_file" "$translated_block_file"
				rm -rf "$block_code_blocks_dir"
				
				((block_index++))
			done
			
			if [ $translation_failed -eq 0 ]; then
				# Reconstruct YAML diff with translated blocks
				echo "  reconstructing YAML diff with translated content"
				translated_yaml_diff=$(mktemp)
				reconstruct_yaml_diff "$diff_file" "$translated_blocks_dir" "$translated_yaml_diff"
				
				# Apply the patch
				patch_translation_file "$target_path" "$translated_yaml_diff"
				echo "  diff file synced and applied"
				rm -f "$translated_yaml_diff" "$diff_block_count_file" "${diff_content_file}.blocks_dir"
				rm -rf "$translated_blocks_dir" "$diff_blocks_dir"
				rm -f "$diff_content_file"
			fi
		fi
		
		# Translation failed - only remove file if it was created during this attempt
		if [ $translation_failed -eq 1 ] && [ "$file_existed_before" = false ]; then
			rm -f "$target_path"
		fi

		# Clean up temp files
		if [ -f "$temp_file" ]; then
			rm -f "$temp_file"
		fi

		if [ "$use_diff_yaml" = true ]; then
			[ -f "$diff_content_file" ] && rm -f "$diff_content_file"
			[ -f "$diff_block_count_file" ] && rm -f "$diff_block_count_file"
			[ -f "${diff_content_file}.blocks_dir" ] && rm -f "${diff_content_file}.blocks_dir"
		fi

	done

	# Clean up after
	if [ -n "$diff_file" ]; then
		rm -f "$diff_file"
	fi
	
	# Return failure status, or 2 if no translation occurred (for caller to know)
	if [ $translation_failed -eq 1 ]; then
		return 1
	elif [ $translation_occurred -eq 0 ]; then
		return 2  # No translation occurred (skipped)
	else
		return 0  # Success
	fi
}


copy_non_md_files() {
	local dir="$1"

	# Find all non-MD files
	find "$dir" -type f ! -name "*.md" -print0 | while IFS= read -r -d '' file; do
	# Get relative path
	relative_path=${file#"$SOURCE_DIR"/}

	for language in "${languages[@]}"; do
		target_path="$TARGET_DIR/$language/$relative_path"

			# Check if target file exists
			if [ ! -f "$target_path" ]; then
				echo "Copying non-MD file: $relative_path to $language"

				# Create target directory if it doesn't exist
				target_dir=$(dirname "$target_path")
				mkdir -p "$target_dir"

				# Copy the file
				cp "$file" "$target_path"
				fi
			done
		done
	}
	# Function to process markdown files
	process_markdown_files() {
		local dir="$1"
		local process_failed=0

	# Find all .md files in the directory and subdirectories
	mapfile -t markdown_files < <(find "$dir" -type f -name "*.md")
	for file in "${markdown_files[@]}"; do
		# Calculate MD5 hash of the file
		current_md5=$(md5sum "$file" | cut -d' ' -f1)

		# Get relative path
		relative_path=${file#"$SOURCE_DIR"/}

		# Check if MD5 exists in the MD5_FILE
		# When not found it returns null, so next we check if it is null
		existing_md5=$(jq -r ".[\"$relative_path\"]" "$MD5_FILE_PATH" 2>/dev/null)

		echo "Processing: $relative_path"

		# Skip if MD5 matches and write yaml diff to file in case we have
		diff_file=
		if [ "${#existing_md5}" -eq 32 ] && [ "$existing_md5" != "$current_md5" ]; then
			# Get the commit where this file was last translated
			last_commit=$(get_last_translation_commit "$relative_path" "$PROJECT_DIR")
			# Use last translation commit if available, otherwise fall back to main branch
			base_commit="${last_commit:-$MAIN_BRANCH}"
			diff_file=$(create_diff_yaml_file "$file" "$base_commit" "$PROJECT_DIR")
			echo " file changed, diff from commit: $base_commit"
			echo " diff file created: $diff_file"
		fi

		all_languages=$(has_all_languages "$relative_path")
		if [ -z "$diff_file" ] && [ "$all_languages" = true ]; then
			echo " all languages exist, skipping"
			continue
		fi

		echo " translating"
		translate_file "$relative_path" "$diff_file"
		translate_result=$?
		
		if [ $translate_result -eq 1 ]; then
			echo "Warning: Translation failed for $relative_path"
			process_failed=1
			continue
		elif [ $translate_result -eq 2 ]; then
			echo "No translation occurred for $relative_path (skipped)"
			# Don't update MD5 if no translation occurred
			continue
		fi

		# Only update MD5 if translation actually succeeded
		# Update the output JSON file with the new MD5
		if ! jq --arg path "$relative_path" --arg md5 "$current_md5" \
			'. + {($path): $md5}' "$MD5_FILE_PATH" > "$MD5_FILE_PATH.tmp"; then
					echo "Error: Failed to update JSON file"
					process_failed=1
					continue
		fi
		mv "$MD5_FILE_PATH.tmp" "$MD5_FILE_PATH"
	done
	return $process_failed
}

# Check if source directory exists
if [ ! -d "$SOURCE_DIR" ]; then
	echo "Error: Source directory does not exist"
	exit 1
fi

# Check that everything installed we need
check_prerequisites "${languages[@]}"

# Check and install translation roles
check_translation_roles || {
	echo "Error setting up translation roles"
	exit 1
}

# Process markdown files first
process_markdown_files "$SOURCE_DIR"

# Process moving of non-md files as a final step
copy_non_md_files "$SOURCE_DIR"

echo "Processing complete."

