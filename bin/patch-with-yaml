#!/usr/bin/env bash

# Check if both input files are provided
if [ "$#" -ne 2 ]; then
	echo "Usage: $0 <target_file> <yaml_diff_file>"
	exit 1
fi

target_file="$1"
yaml_diff="$2"
temp_file=$(mktemp)

# Create empty target file if it doesn't exist
touch "$target_file"

# Copy the target file to temp file
cp "$target_file" "$temp_file"

# Arrays to store operations
declare -a operations_type
declare -a operations_line
declare -a operations_content

# Parse YAML file and collect all operations
current_op=""
current_line=""
block_content=""
content_mode=false

while IFS= read -r line; do
	# If we're in content mode and encounter a new key, save the previous block
	if [[ $content_mode == true && ($line =~ ^add[0-9]+:\ \| || $line =~ ^del[0-9]+:) ]]; then
		# Save the current operation
		if [ "$current_op" == "add" ]; then
			operations_type+=("add")
			operations_line+=("$current_line")
			operations_content+=("$block_content")
		fi
		content_mode=false
		block_content=""
	fi

	# Check for new key definitions
	if [[ $line =~ ^add([0-9]+):\ \| ]]; then
		current_op="add"
		current_line="${BASH_REMATCH[1]}"
		content_mode=true
		block_content=""
		continue
	elif [[ $line =~ ^del([0-9]+): ]]; then
		# Save delete operation immediately
		operations_type+=("del")
		operations_line+=("${BASH_REMATCH[1]}")
		operations_content+=("")
		continue
	fi

	# If in content mode, collect content lines (remove the leading two spaces)
	if [ "$content_mode" == true ]; then
		if [[ $line =~ ^[[:space:]]+ ]]; then
			line="${line:2}"  # Remove leading two spaces
		fi

		if [ -z "$block_content" ]; then
			block_content="$line"
		else
			block_content="${block_content}"$'\n'"$line"
		fi
	fi
done < "$yaml_diff"

# Process any remaining content block at the end of file
if [ "$content_mode" == true ] && [ "$current_op" == "add" ] && [ -n "$block_content" ]; then
	operations_type+=("add")
	operations_line+=("$current_line")
	operations_content+=("$block_content")
fi

# First pass: identify del+add pairs at same line (these are modifications)
declare -a is_modification
for ((i=0; i<${#operations_type[@]}; i++)); do
	is_modification[$i]=0
done

for ((i=0; i<${#operations_type[@]}-1; i++)); do
	if [ "${operations_type[$i]}" == "del" ] && [ "${operations_type[$((i+1))]}" == "add" ]; then
		if [ "${operations_line[$i]}" == "${operations_line[$((i+1))]}" ]; then
			# Mark both as part of a modification
			is_modification[$i]=1
			is_modification[$((i+1))]="mod"
		fi
	fi
done

# Apply operations in REVERSE order (from highest line number to lowest)
# This ensures line numbers remain stable as we process
for ((i=${#operations_type[@]}-1; i>=0; i--)); do
	# Skip if this was marked as part of a modification pair (the del part)
	if [ "${is_modification[$i]}" == "1" ]; then
		continue
	fi

	op_type="${operations_type[$i]}"
	op_line="${operations_line[$i]}"
	op_content="${operations_content[$i]}"

	if [ "${is_modification[$i]}" == "mod" ]; then
		# This is a modification (del+add at same line)
		# Count how many lines are in the add content
		num_lines=$(echo "$op_content" | wc -l)
		
		# Replace N lines starting at op_line with the new content
		if [ -s "$temp_file" ]; then
			end_line=$((op_line + num_lines - 1))
			awk -v start="$op_line" -v end="$end_line" -v content="$op_content" '
			NR == start {print content; skip=1}
			NR > end {skip=0}
			!skip {if (NR != start) print}
			' "$temp_file" > "${temp_file}.new" && mv "${temp_file}.new" "$temp_file"
		fi
	elif [ "$op_type" == "del" ]; then
		# Delete the line
		if [ -s "$temp_file" ]; then
			awk -v line="$op_line" 'NR != line' "$temp_file" > "${temp_file}.new" && mv "${temp_file}.new" "$temp_file"
		fi
	elif [ "$op_type" == "add" ]; then
		# Insert content at specified line (pushes existing line down)
		if [ ! -s "$temp_file" ]; then
			echo "$op_content" > "$temp_file"
		else
			# Check if line number is beyond file length
			file_lines=$(wc -l < "$temp_file")
			if [ "$op_line" -gt "$file_lines" ]; then
				# Append to end of file
				echo "$op_content" >> "$temp_file"
			else
				# Insert at specified line
				awk -v line="$op_line" -v content="$op_content" '
				NR == line {print content}
				{print}
				' "$temp_file" > "${temp_file}.new" && mv "${temp_file}.new" "$temp_file"
			fi
		fi
	fi
done

# Output the final patched content
cat "$temp_file"
rm "$temp_file"
